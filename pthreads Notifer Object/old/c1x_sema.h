/* c1x_sema.h
Declares and defines the proposed C1X semaphore object
(C) 2011 Niall Douglas http://www.nedproductions.biz/


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef C1X_SEMA_H
#define C1X_SEMA_H
#include "c1x_compat.h"

/* This semaphore is a very simple object. It basically is an atomic count.
When the count goes below 0, everything waits and when >= 0 everything passes.
It is entirely lock free unless a wait may need to be performed.

To use as a semaphore:
sema_create(&sema, 0);      // Default to non-signalled i.e. don't permit anything through
sema_wait(&sema, -1);       // This decrements the count and waits if less than zero
sema_incr(&sema, 1);        // This increments the count, freeing one waiter if there are any

To use as an event:
sema_create(&sema, -1);     // Default to non-signalled i.e. don't permit anything through
sema_wait(&sema, 0);        // Waits if less than zero
if(sema_incr(&sema, 0)>=0)  // Polls to see if event is signalled
sema_set(&sema, 0);         // Signal event. All waiters are released. Any new waiters permitted through.
sema_set(&sema, -1);        // Designal event. From now on now new waiters permitted through.

To use as a mutex which can be handed off to other threads:
sema_create(&sema, 1);      // Default to signalled i.e. permit one thing through
sema_wait(&sema, -1);       // This decrements the count, letting the first thing through but not others
sema_incr(&sema, 1);        // This increments the count, freeing one waiter if there are any

To use as a reader-writer lock (prefers writers):
sema_create(&readers, 0);   // Permit no writers while there are readers
sema_create(&writers, 1);   // Permit one writer through at once
mtx_create(&writerlock);    // Prevent multiple writers
// To lock for reading
if(sema_incr(&writers, 0)<1) sema_wait(&writers, -1); // Wait if something wants to write
sema_incr(&readers, -1);    // Marks me as reading
... do reading ...
sema_incr(&readers, 1);     // Marks me as done reading
// To lock for writing
mtx_lock(&writerlock);
sema_incr(&writers, -1);    // This decrements the count, stopping any new readers
sema_wait(&readers, 0);     // This waits until the readers are done
... do writing ...
sema_set(&writers, 1);      // This releases the readers
mtx_unlock(&writerlock);

*/

/* Define the sema_t type */
typedef struct sema_s
{
  atomic_ptrdiff_t count;

  mtx_t mtx;          /* Only ever held when a thread might be slept or woken */
  cnd_t cond;
  ptrdiff_t waiters;  /* Number of threads waiting for this semaphore to become positive */
  ptrdiff_t towake;   /* Number of threads to be woken */
} sema_t;

/* Creates with initial count. */
inline int sema_create(sema_t *sema, ptrdiff_t initial);

/* Destroys. If anything is waiting it fails. */
inline int sema_destroy(sema_t *sema);

/* Adds the increment to the count. If by using this function the
count goes from being negative to being positive, all waiters are
released. If the count instead goes from negative to less negative,
that number of waiters are released. Returns former count. */
inline ptrdiff_t sema_incr(sema_t *sema, ptrdiff_t incr);

/* Sets the count to val. If by using this function the
count goes from being negative to being positive, all waiters are
released. If the count instead goes from negative to less negative,
that number of waiters are released. Returns former count. */
inline ptrdiff_t sema_set(sema_t *sema, ptrdiff_t val);

/* Adds the increment to count. If less than zero, waits. */
inline int sema_wait(sema_t *sema, ptrdiff_t incr);

/* Adds the increment to count. If less than zero, waits for a time. */
inline int sema_timedwait(sema_t *RESTRICT sema, ptrdiff_t incr, const struct timespec *RESTRICT ts);




inline int sema_create(sema_t *sema, ptrdiff_t initial)
{
  atomic_init(&sema->count, initial);
  if(thrd_success!=mtx_init(&sema->mtx, mtx_timed)) return thrd_error;
  if(thrd_success!=cnd_init(&sema->cond)) return thrd_error;
  sema->waiters=sema->towake=0;
  return thrd_success;
}

inline int sema_destroy(sema_t *sema)
{
  int ret=thrd_success;
  if(sema->count<0) return thrd_error;
  mtx_lock(&sema->mtx);
  if(sema->waiters)
  {
    mtx_unlock(&sema->mtx);
    return thrd_error;
  }
  mtx_unlock(&sema->mtx);
  cnd_destroy(&sema->cond);
  mtx_destroy(&sema->mtx);
  return ret;
}

inline void internal_sema_wake(sema_t *sema, ptrdiff_t orig, ptrdiff_t incr)
{
  /* If the increment was positive, and there are either waiters or count
  became positive, try waking things */
  if(incr>0 && (orig+incr>=0 || sema->waiters))
  { /* Wake things */
    mtx_lock(&sema->mtx);
    /* Still got waiters? */
    if(sema->waiters)
    {
      /* Is the increment more than or equal to the number of waiters, or did our
      increment cause the count to become positive? If so, release everything */
      if(incr>=sema->waiters || orig+incr>=0)
      {
        sema->towake+=sema->waiters;
        sema->waiters=0;
        cnd_broadcast(&sema->cond);
      }
      else
      {
        ptrdiff_t n;
        sema->towake+=incr;
        sema->waiters-=incr;
        for(n=0; n<incr; n++)
          cnd_signal(&sema->cond);
      }
    }
    mtx_unlock(&sema->mtx);
  }
}

inline ptrdiff_t sema_incr(sema_t *sema, ptrdiff_t incr)
{
  ptrdiff_t orig;
  if(!incr) return sema->count;
  orig=atomic_fetch_add_explicit(&sema->count, incr, memory_order_relaxed);
  internal_sema_wake(sema, orig, incr);
  return orig;
}

inline ptrdiff_t sema_set(sema_t *sema, ptrdiff_t val)
{
  ptrdiff_t orig;
  orig=atomic_exchange_explicit(&sema->count, val, memory_order_relaxed);
  internal_sema_wake(sema, orig, val-orig);
  return orig;
}

inline int sema_wait(sema_t *sema, ptrdiff_t incr)
{
  ptrdiff_t val=atomic_fetch_add_explicit(&sema->count, incr, memory_order_relaxed);
  val+=incr;
  if(val<0)
  { /* Begin to sleep */
    mtx_lock(&sema->mtx);
    /* Is the count still below zero? */
    if(sema->count<0)
    {
      /* Wait until I am woken while handling spurious wakes */
      do
      {
        sema->waiters++;
        /* Make sure everything is written before we sleep */
        /*atomic_thread_fence(memory_order_seq_cst);*/
        cnd_wait(&sema->cond, &sema->mtx);
      } while(!sema->towake);
      sema->towake--;
    }
    mtx_unlock(&sema->mtx);
  }
  return thrd_success;
}


#endif
