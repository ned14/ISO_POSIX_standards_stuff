/* n1527lib_dlmalloc.c
A modified dlmalloc implementation of the N1527 proposal for the C programming language
(C) 2010-2011 Niall Douglas http://www.nedproductions.biz/


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "../n1527lib.h"
#include <string.h>
#include <errno.h>
#include <malloc.h>

#if 1
/* Temporary hacky stuff */
  #ifdef WIN32
   #define DLMALLOC_EXPORT extern __declspec(dllexport)
  #elif defined(__GNUC__)
   #define DLMALLOC_EXPORT extern __attribute__ ((visibility("default")))
  #endif
#endif
#define ONLY_MSPACES 1
/*#define DEBUG 1*/
#include "malloc.c.h"

struct mpool_s {
  struct mpool_APIset *APIset;   /* This HAS to be here! */
  mspace ms;
  uintmax_t flags;
  size_t alignment;
  size_t sizerounding;
};

static mpool createpool(struct mpool_attribute_data **RESTRICT attributes);
static void destroypool(mpool pool);
static N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void **_batch(mpool pool, int *errnos, void **ptrs, size_t *RESTRICT sizes, size_t *RESTRICT count, uintmax_t flags);
static N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *_calloc(mpool pool, size_t nmemb, size_t size);
static void _free(mpool pool, void *ptr);
static N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *_malloc(mpool pool, size_t size);
static N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *_realloc(mpool pool, void *ptr, size_t size);
static N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *_try_realloc(mpool pool, void *ptr, size_t size);
static size_t _usable_size(mpool pool, void *ptr);
static mpool _ownerpool(void *ptr);
static struct mpool_APIset dlmalloc_apiset = {
  NULL,
  createpool,
  destroypool,
  _batch,
  _calloc,
  _free,
  _malloc,
  _realloc,
  _try_realloc,
  _usable_size,
  _ownerpool,
};

struct mpool_APIset default_allocator_APIset(void)
{
  return dlmalloc_apiset;
}
#if 1
/* Temporary hacky stuff */
N1527MALLOCEXTSPEC mspace get_dlmalloc_mspace(mpool pool)
{
  struct mpool_s *m=(struct mpool_s *) pool;
  return m->ms;
}
#endif

mpool createpool(struct mpool_attribute_data **RESTRICT attributes)
{
  mspace ms;
  struct mpool_s *m;
  ensure_initialization();
  if((ms=create_mspace(0, 1)))
  {
    if(!(m=(struct mpool_s *) mspace_calloc(ms, 1, sizeof(struct mpool_s))))
    {
      destroy_mspace(ms);
      return NULL;
    }
    m->APIset=&dlmalloc_apiset;
    m->ms=ms;
    if(attributes)
    {
      for(; *attributes; attributes++)
      {
        switch((*attributes)->id)
        {
        case MPOOL_ATTRIBUTE_ZEROMEMORY:
          {
            m->flags|=MPOOL_ZERO_MEMORY|MPOOL_ZERO_FREES;
            break;
          }
        case MPOOL_ATTRIBUTE_ALIGNMENT:
          {
            struct mpool_attribute_alignment *a=(struct mpool_attribute_alignment *) *attributes;
            m->alignment=a->alignment;
            break;
          }
        case MPOOL_ATTRIBUTE_SIZEROUNDING:
          {
            struct mpool_attribute_sizerounding *a=(struct mpool_attribute_sizerounding *) *attributes;
            m->sizerounding=a->rounding;
            break;
          }
        default:
          {
            (*attributes)->error=ENOENT;
          }
        }
      }
    }
    return m;
  }
  return NULL;
}

void destroypool(mpool pool)
{
  struct mpool_s *m=(struct mpool_s *) pool;
  destroy_mspace(m->ms);
}

FORCEINLINE N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void **_batch(mpool pool, int *errnos, void **ptrs, size_t *RESTRICT sizes, size_t *RESTRICT count, uintmax_t flags)
{
  struct mpool_s *m=(struct mpool_s *) pool;
  size_t maxn=*count, _count=0;
  uintmax_t combinedflags=flags|m->flags;
  /* Take care of malloc, calloc and free first as these have dlmalloc optimised batch implementations */
  if(!ptrs || !ptrs[0] || !sizes)
  {
    if(1==maxn)
    {
      if(!ptrs)
      {
        if(!(ptrs=(void **) mspace_calloc(m->ms, maxn, sizeof(void *))))
        {
          *count=0;
          return NULL;
        }
      }
      if(errnos) errnos[0]=0;
      if(!sizes) /* free */
      {
        if(combinedflags & MPOOL_ZERO_FREES)
          memset(ptrs[0], 0, mspace_usable_size(ptrs[0]));
        mspace_free(m->ms, ptrs[0]);
        ptrs[0]=0;
        _count=1;
      }
      else if(!ptrs[0]) /* malloc or calloc */
      {
        if(m->alignment<=MALLOC_ALIGNMENT)
        {
          if(!(ptrs[0]=(combinedflags & MPOOL_ZERO_MEMORY) ? mspace_calloc(m->ms, 1, sizes[0]) : mspace_malloc(m->ms, sizes[0])))
          {
            if(errnos) errnos[0]=ENOMEM;
          }
          else
          {
            sizes[0]=mspace_usable_size(ptrs[0]);
            _count=1;
          }
        }
        else
        {
          if(!(ptrs[0]=mspace_memalign(m->ms, m->alignment, sizes[0])))
          {
            if(errnos) errnos[0]=ENOMEM;
          }
          else
          {
            sizes[0]=mspace_usable_size(ptrs[0]);
            if(combinedflags & MPOOL_ZERO_MEMORY)
              memset(ptrs[0], 0, sizes[0]);
            _count=1;
          }
        }
      }
    }
    else /* It's a batch op */
    {
      if(!sizes) /* free */
      {
        size_t n;
        mspace_bulk_free(m->ms, ptrs, maxn);
        for(n=0; n<maxn; n++)
        {
          ptrs[n]=0;
          if(errnos) errnos[n]=0;
        }
        _count=maxn;
      }
      else if(!ptrs || !ptrs[0]) /* malloc or calloc */
      {
        if(m->alignment<=MALLOC_ALIGNMENT)
        {
          ptrs=ialloc((mstate) m->ms, maxn, sizes, (combinedflags & MPOOL_ZERO_MEMORY) ? 2 : 0, ptrs);
          if(errnos)
          {
            size_t n;
            for(n=0; n<maxn; n++)
              errnos[n]=(ptrs && ptrs[n]) ? 0 : ENOMEM;
          }
          if(ptrs) _count=maxn;
        }
        else
        {
          fprintf(stderr, "Aligned batch malloc not implemented yet!\n");
          abort();
#ifdef __GNUC__
#warning Aligned batch malloc not yet implemented
#endif
#ifdef _MSC_VER
#pragma message(__FILE__ ": WARNING: Aligned batch malloc not yet implemented")
#endif
        }
      }
    }
  }
  else /* realloc */
  {
    size_t n;
    for(n=0; n<maxn; n++)
    {
      void *temp;
      size_t oldsize=(combinedflags & (MPOOL_ZERO_MEMORY|MPOOL_ZERO_FREES)) ? mspace_usable_size(ptrs[n]) : 0;
      if(combinedflags & MPOOL_ZERO_FREES)
      { /* Zero any excess bytes */
        if(sizes[n]<oldsize)
          memset((char *) ptrs[n]+sizes[n], 0, oldsize-sizes[n]);
      }
      if(!(temp=(flags & MPOOL_PREVENT_MOVE) ? mspace_realloc_in_place(m->ms, ptrs[n], sizes[n]) : mspace_realloc(m->ms, ptrs[n], sizes[n])))
      {
        if(errnos) errnos[n]=(flags & MPOOL_PREVENT_MOVE) ? ENOSPC : ENOMEM;
      }
      else
      {
        ptrs[n]=temp;
        sizes[n]=mspace_usable_size(ptrs[n]);
        if(combinedflags & MPOOL_ZERO_MEMORY)
        { /* Zero any new bytes */
          if(sizes[n]>oldsize)
            memset((char *) ptrs[n]+oldsize, 0, sizes[n]-oldsize);
        }
        _count++;
      }
    }
  }
  *count=_count;
  return ptrs;
}     

/* Make the compiler generate specialised versions for each of these */
N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *_calloc(mpool pool, size_t nmemb, size_t size)
{
  void *ret=0;
  size_t count=1;
  /* Overflow check already done for us */
  size*=nmemb;
  return _batch(pool, NULL, &ret, &size, &count, MPOOL_ZERO_MEMORY), ret;
}
void _free(mpool pool, void *ptr)
{
  size_t count=1;
  _batch(pool, NULL, &ptr, NULL, &count, 0);
}
N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *_malloc(mpool pool, size_t size)
{
  void *ret=0;
  size_t count=1;
  return _batch(pool, NULL, &ret, &size, &count, 0), ret;
}
N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *_realloc(mpool pool, void *ptr, size_t size)
{
  size_t count=1;
  return _batch(pool, NULL, &ptr, &size, &count, 0), ptr;
}
N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *_try_realloc(mpool pool, void *ptr, size_t size)
{
  size_t count=1;
  return _batch(pool, NULL, &ptr, &size, &count, MPOOL_PREVENT_MOVE), ptr;
}
size_t _usable_size(mpool pool, void *ptr)
{
  return mspace_usable_size(ptr);
}
mpool _ownerpool(void *ptr)
{
  struct mpool_s *m=0;
#ifdef __GNUC__
#warning ownerpool() not yet implemented
#endif
#ifdef _MSC_VER
#pragma message(__FILE__ ": WARNING: ownerpool() not yet implemented")
#endif
  return NULL;
}

