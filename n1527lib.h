/* n1527lib.h
Declares and defines the N1527 proposal for the C programming language
(C) 2010-2011 Niall Douglas http://www.nedproductions.biz/


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

/*#define N1527MALLOC_DONTREPLACESTD*/

#ifndef N1527LIB_INCLUDED
#define N1527LIB_INCLUDED
#define calloc calloc_disabled
#define free free_disabled
#define malloc malloc_disabled
#define realloc realloc_disabled
#if 1 /* You have a modern compiler */
#include <stdint.h>
#else /* else if you have no stdint.h */
typedef size_t uintmax_t;
#endif
#include <stdlib.h>
#undef calloc
#undef free
#undef malloc
#undef realloc

/*! \file n1527lib.h
\brief Declares and defines the N1527 proposal for the C programming language
*/

#if __STDC_VERSION__ < 199901L		/* not C99 or better */
#if !defined(RESTRICT) && (defined(_MSC_VER) || defined(__GNUC__))
#define RESTRICT __restrict
#endif
#if !defined(__cplusplus) && !defined(inline) && (defined(_MSC_VER) || defined(__GNUC__))
#define inline __inline
#endif
/* These are constants from C1X */
typedef unsigned char _Bool;

/* If we don't have it we don't have it */
#ifndef RESTRICT
#define RESTRICT
#endif
#endif

/*! \def N1527MALLOCEXTSPEC
\brief Defines how this API is to be made visible.

N1527MALLOCEXTSPEC can be defined to be __declspec(dllexport) or
__attribute__ ((visibility("default"))) or whatever you like. It defaults
to extern unless N1527MALLOC_DLL_EXPORTS is set as it would be when building
the DLL.
 */
#ifndef N1527MALLOCEXTSPEC
 #ifdef N1527MALLOC_DLL_EXPORTS
  #ifdef WIN32
   #define N1527MALLOCEXTSPEC extern __declspec(dllexport)
  #elif defined(__GNUC__)
   #define N1527MALLOCEXTSPEC extern __attribute__ ((visibility("default")))
  #endif
 #else
 #endif
#endif
#ifndef N1527MALLOCEXTSPEC
#define N1527MALLOCEXTSPEC extern
#endif

#if defined(_MSC_VER) && _MSC_VER>=1400
 #define N1527MALLOCPTRATTR __declspec(restrict)
 #define N1527MALLOCNOALIASATTR __declspec(noalias)
#endif
#ifdef __GNUC__
 #define N1527MALLOCPTRATTR __attribute__ ((malloc))
#endif
/*! \def N1527MALLOCPTRATTR
\brief Defined to the specifier for a pointer which points to a memory block. Like N1527MALLOCNOALIASATTR, but sadly not identical. */
#ifndef N1527MALLOCPTRATTR
 #define N1527MALLOCPTRATTR
#endif
/*! \def N1527MALLOCNOALIASATTR
\brief Defined to the specifier for a pointer which does not alias any other variable. */
#ifndef N1527MALLOCNOALIASATTR
 #define N1527MALLOCNOALIASATTR
#endif



/******** The standard definition stuff begins here ********/

#ifndef MPOOL_FLAGS_DEFINED
#define MPOOL_FLAGS_DEFINED

#define MPOOL_ZERO_MEMORY          (1<<0)       //!< Zero fill allocated memory
#define MPOOL_ZERO_FREES           (1<<1)       //!< Zero fill deallocated memory
#define MPOOL_PREVENT_MOVE         (1<<2)       //!< Prevents a reallocation relocating the block
#define MPOOL_FREE_NOW             (1<<3)       //!< Inhibits delayed freeing of this particular block

#define MPOOL_HIGH_ADDR            (1<<12)      //!< Hints that high addresses ought to be used for this particular block

#define MPOOL_USERFLAGS_FIRST      (1<<16)
#define MPOOL_USERFLAGS_LAST       (1<<31)
#define MPOOL_USERFLAGS_MASK       0xffff0000

#endif /* M2_FLAGS_DEFINED */

#if defined(__cplusplus)
extern "C" {
#endif

struct mpool_s;
typedef struct mpool_s *mpool;

#ifndef MPOOL_ATTRIBUTE_DEFINED
#define MPOOL_ATTRIBUTE_DEFINED
/*! \enum mpool_attribute
\brief Encodes a memory pool attribute
*/
enum mpool_attribute {
  MPOOL_ATTRIBUTE_NULL,                     //!< This attribute will be ignored
  MPOOL_ATTRIBUTE_DESTROYUNUSED,            //!< Sets always destroy unused memory for this memory pool. See struct mpool_attribute_destroyunused
  MPOOL_ATTRIBUTE_ALIGNMENT,                //!< Sets alignment for this memory pool. See struct mpool_attribute_alignment
  MPOOL_ATTRIBUTE_SIZEROUNDING,             //!< Sets size rounding for this memory pool. See struct mpool_attribute_sizerounding
  MPOOL_ATTRIBUTE_USESYSTEMPOOL,            //!< Sets the memory pool to be used by a memory pool for obtaining and releasing system memory. See struct mpool_attribute_usesystempool

  MPOOL_ATTRIBUTE_INSTALL_ALLOCATOR=256,    //!< Installs a new allocator
  MPOOL_ATTRIBUTE_REMOVE_ALLOCATOR,         //!< Removes a previously installed allocator

  MPOOL_ATTRIBUTE_LAST=1024                 //!< First free attribute available
};
#endif

#ifndef MPOOL_ATTRIBUTE_DATA_DEFINED
#define MPOOL_ATTRIBUTE_DATA_DEFINED
/*! \brief Describes the common header for all memory pool attributes */
struct mpool_attribute_data;
struct mpool_attribute_data {
  int id;                                   //!< An id from enum mpool_attribute, or proprietary extension
  int (*compare)(const struct mpool_attribute_data *me, const struct mpool_attribute_data *b);
  int error;                                //!< Zero on entry, set to error if there was an error applying this attribute
};
/*! \brief Sets that all memory in a memory pool is destroyed (e.g. zeroed) as soon as it becomes unused. Useful for when
storing encryption keys etc. Also implies that any newly allocated memory will always be zero filled. */
struct mpool_attribute_destroyunused {
  int id;                                   //!< Set to MPOOL_ATTRIBUTE_DESTROYUNUSED
  int (*compare)(const struct mpool_attribute_data *me, const struct mpool_attribute_data *b);
  int error;                                //!< Zero on entry, set to error if there was an error applying this attribute
};
/*! \brief Describes the minimum alignment for all data allocated within a memory pool */
struct mpool_attribute_alignment {
  int id;                                   //!< Set to MPOOL_ATTRIBUTE_ALIGNMENT
  int (*compare)(const struct mpool_attribute_data *me, const struct mpool_attribute_data *b);
  int error;                                //!< Zero on entry, set to error if there was an error applying this attribute
  size_t alignment;                         //!< Set to the alignment to be used for allocations in this pool
};
inline int mpool_attribute_alignment_compare(const struct mpool_attribute_data *me, const struct mpool_attribute_data *b) { return !b ? 1 /* alignment is important */ : ((const struct mpool_attribute_alignment *) me)->alignment<((const struct mpool_attribute_alignment *) b)->alignment; }
/*! \brief Describes the size rounding for all data allocated within a memory pool */
struct mpool_attribute_sizerounding {
  int id;                                   //!< Set to MPOOL_ATTRIBUTE_SIZEROUNDING
  int (*compare)(const struct mpool_attribute_data *me, const struct mpool_attribute_data *b);
  int error;                                //!< Zero on entry, set to error if there was an error applying this attribute
  size_t rounding;
};
inline int mpool_attribute_sizerounding_compare(const struct mpool_attribute_data *me, const struct mpool_attribute_data *b) { return !b ? 0 /* rounding is not important */ : ((const struct mpool_attribute_sizerounding *) me)->rounding<((const struct mpool_attribute_sizerounding *) b)->rounding; }
/*! \brief Sets the memory pool to be used by a memory pool for obtaining and releasing system memory */
struct mpool_attribute_usesystempool {
  int id;                                   //!< Set to MPOOL_ATTRIBUTE_USESYSTEMPOOL
  int (*compare)(const struct mpool_attribute_data *me, const struct mpool_attribute_data *b);
  int error;                                //!< Zero on entry, set to error if there was an error applying this attribute
  mpool systempool;
};
inline int mpool_attribute_usesystempool_compare(const struct mpool_attribute_data *me, const struct mpool_attribute_data *b) { return ((const struct mpool_attribute_usesystempool *) me)->systempool!=((const struct mpool_attribute_usesystempool *) b)->systempool; }
/*! \brief Defines an allocator API set */
struct mpool_APIset {
  int (*rateattributes)(const size_t *RESTRICT alignments[], const size_t *RESTRICT roundings[], const struct mpool_attribute_data **RESTRICT attributes); //!< Scores a set of attributes. Higher is better.
  mpool (*createpool)(struct mpool_attribute_data **RESTRICT attributes, mpool systempool, int (*vanotify)(mpool pool, mpool systempool, void **ptrs, size_t *RESTRICT oldsizes, size_t *RESTRICT newsizes, size_t count));         //!< Creates a pool
  void (*destroypool)(mpool pool);                                                                  //!< Destroys a pool
  void **(*batch)(mpool pool, int *errnos, void **ptrs, size_t *RESTRICT sizes, size_t *RESTRICT count, uintmax_t flags);
  void *(*calloc)(mpool pool, size_t nmemb, size_t size);
  void (*free)(mpool pool, void *ptr);
  void *(*malloc)(mpool pool, size_t size);
  void *(*realloc)(mpool pool, void *ptr, size_t size);
  void *(*try_realloc)(mpool pool, void *ptr, size_t size);
  size_t (*usable_size)(mpool pool, void *ptr);
  mpool (*ownerpool)(void *ptr);
};
#endif

/*! \brief Returns a sorted list of minimum roundings for the allocators available */
N1527MALLOCEXTSPEC size_t mpool_minimum_roundings(size_t roundings[], size_t size);
/*! \brief Obtains a desired memory pool. Make SURE attributes is statically declared! */
N1527MALLOCEXTSPEC mpool mpool_obtain(struct mpool_attribute_data **attributes);
/*! \brief Destroys a memory pool */
N1527MALLOCEXTSPEC void mpool_release(mpool pool);
/*! \brief Returns all known memory pools */
N1527MALLOCEXTSPEC size_t mpool_knownpools(mpool *poollist, size_t poollistlen);
/*! \brief Obtains the usage count, alignments, roundings and attributes for a memory pool, returning 1 if pool found */
N1527MALLOCEXTSPEC _Bool mpool_info(mpool pool, size_t *RESTRICT usagecount, const size_t *RESTRICT alignments[], const size_t *RESTRICT roundings[], const struct mpool_attribute_data ***RESTRICT attributes);
/*! \brief Synchronises any outstanding operations on a memory pool for the calling thread */
N1527MALLOCEXTSPEC void mpool_sync(mpool pool);

/*! \brief Used to request the default pool from mpool_obtain() */
#define MPOOL_DEFAULT ((struct mpool_attribute_data **)(size_t) 0)
/*! \brief Used to request the kernel pool from mpool_obtain() */
#define MPOOL_KERNEL ((struct mpool_attribute_data **)(size_t) 1)

struct mpool_s_ {
  struct mpool_APIset *APIset;
};

/*! \brief Performs a sequence of allocations, or resizes, or deallocations.

Allocations are when sizes and sizes[] is non-zero, but ptrs or ptrs[] is zero.
Resizes are when both ptrs[] and sizes[] are non-zero. Deallocations are when
ptrs[] is non-zero but sizes is zero. Note that you cannot mix operations,
so either you are allocating, or deallocating, or resizing - this lets the allocator
use highly optimised implementations.

You should ALWAYS check that *count on exit is the same as it was on entry. If it
is different then one or more of the individual operations failed. You can find out
which and its cause by specifying an errnos array on entry.

Returns whatever ptrs was on entry, though a zero ptrs on entry has a special case.
Some allocators don't support a zero ptrs parameter and will always return
zero, but for those which do support a zero ptrs parameter it will allocate a suitably
sized array of pointers and return it from the function - in this case you must separately
free the pointers array. */
inline N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void **mpool_batch(mpool pool, int *errnos, void **ptrs, size_t *RESTRICT sizes, size_t *RESTRICT count, uintmax_t flags)
{
  struct mpool_s_ *p=(struct mpool_s_ *) pool;
  return p->APIset->batch(pool, errnos, ptrs, sizes, count, flags);
}
/*! \brief Allocates zeroed memory */
inline N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *mpool_calloc(mpool pool, size_t nmemb, size_t size)
{
  struct mpool_s_ *p=(struct mpool_s_ *) pool;
  if((size_t)-1/size<nmemb) { return 0; }
  return p->APIset->calloc(pool, nmemb, size);
}
/*! \brief Frees blocks */
inline void mpool_free(mpool pool, void *ptr)
{
  struct mpool_s_ *p=(struct mpool_s_ *) pool;
  p->APIset->free(pool, ptr);
}
/*! \brief Allocates memory */
inline N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *mpool_malloc(mpool pool, size_t size)
{
  struct mpool_s_ *p=(struct mpool_s_ *) pool;
  return p->APIset->malloc(pool, size);
}
/*! \brief Resizes an existing block */
inline N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *mpool_realloc(mpool pool, void *ptr, size_t size)
{
  struct mpool_s_ *p=(struct mpool_s_ *) pool;
  return p->APIset->realloc(pool, ptr, size);
}
/*! \brief A non-relocating resize */
inline N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *mpool_try_realloc(mpool pool, void *ptr, size_t size)
{
  struct mpool_s_ *p=(struct mpool_s_ *) pool;
  return p->APIset->try_realloc(pool, ptr, size);
}
/*! \brief Returns the size of an existing block */
inline size_t mpool_usable_size(mpool pool, void *ptr)
{
  struct mpool_s_ *p=(struct mpool_s_ *) pool;
  return p->APIset->usable_size(pool, ptr);
}
/*! \brief Returns the memory pool owning the block */
inline mpool mpool_owner(void *ptr)
{
#ifdef __GNUC__
#warning mpool_owner() not yet implemented
#endif
#ifdef _MSC_VER
#pragma message(__FILE__ ": WARNING: mpool_owner() not yet implemented")
#endif
  return NULL;
}

#ifndef N1527MALLOC_DONTREPLACESTD
/*! \brief Allocates zeroed memory */
inline N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *calloc(size_t nmemb, size_t size)
{
  return mpool_calloc(mpool_obtain(0), nmemb, size);
}
/*! \brief Frees blocks */
inline void free(void *ptr)
{
  mpool_free(mpool_obtain(0), ptr);
}
/*! \brief Allocates memory */
inline N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *malloc(size_t size)
{
  return mpool_malloc(mpool_obtain(0), size);
}
/*! \brief Returns the size of an existing block */
inline size_t malloc_usable_size(void *ptr)
{
  return mpool_usable_size(mpool_obtain(0), ptr);
}
/*! \brief Resizes an existing block */
inline N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *realloc(void *ptr, size_t size)
{
  return mpool_realloc(mpool_obtain(0), ptr, size);
}
/*! \brief A non-relocating resize */
inline N1527MALLOCNOALIASATTR N1527MALLOCPTRATTR void *try_realloc(void *ptr, size_t size)
{
  return mpool_try_realloc(mpool_obtain(0), ptr, size);
}
#endif

#if defined(__cplusplus)
}
#endif

#endif /* N1527LIB_INCLUDED */
