/* c1x_compat.h
Declares and defines stuff from C11
(C) 2011-2012 Niall Douglas http://www.nedproductions.biz/


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef C11_COMPAT_H
#define C11_COMPAT_H

#include <stdlib.h>
#if __STDC_VERSION__ > 200000L || defined(__GNUC__)
#include <stdatomic.h>
#include <threads.h>
#else

#ifdef _MSC_VER
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <intrin.h>
#include <process.h>
#endif

/* We need inline */
#if !defined(__cplusplus) && !defined(inline) && (defined(_MSC_VER) || defined(__GNUC__))
#define inline __inline
#endif

#if __STDC_VERSION__ < 199901L		/* not C99 or better */
#if !defined(RESTRICT) && (defined(_MSC_VER) || defined(__GNUC__))
#define RESTRICT __restrict
#endif
#endif

#ifndef RESTRICT
#define RESTRICT
#endif

typedef unsigned char _Bool;


/****************** Declare and define just those bits of stdatomic.h we need ***********************/
typedef unsigned int atomic_uint;

typedef enum memory_order
{
  memory_order_relaxed,
  memory_order_consume,
  memory_order_acquire,
  memory_order_release,
  memory_order_acq_rel,
  memory_order_seq_cst
} memory_order;

inline void atomic_init(volatile atomic_uint *o, unsigned int v)
{
  /* Both MSVC and GCC do the right thing when it's marked volatile */
  *o=v;
}

#ifdef _MSC_VER
inline void atomic_thread_fence(memory_order order)
{ /*
acquire = prevents memory operations after the acquire moving before but
permits previous operations to move downwards

release = prevents memory operations before the release moving after but
permits subsequent operations to move upwards
*/
  switch(order)
  {
  case memory_order_acquire:
  case memory_order_release:
  case memory_order_acq_rel:
  case memory_order_seq_cst:
    MemoryBarrier();
    return;
  default:
    return;
  }
}
inline void atomic_store_explicit(volatile atomic_uint *o, unsigned int v, memory_order order)
{
  switch(order)
  {
  default:
    InterlockedExchange((volatile long *) o, (long) v);
    return;
  }
}
inline unsigned int atomic_load_explicit(volatile atomic_uint *o, memory_order order)
{
  /* Both MSVC and GCC do the right thing when it's marked volatile */
  return *o;
}
inline unsigned int atomic_exchange_explicit(volatile atomic_uint *o, unsigned int v, memory_order order)
{
  switch(order)
  {
#ifdef InterlockedExchangeAcquire
  case memory_order_acquire:
    return (unsigned int) InterlockedExchangeAcquire((volatile long *) o, v);
  case memory_order_release:
    return (unsigned int) InterlockedExchangeRelease((volatile long *) o, v);
#endif
  default:
    return (unsigned int) InterlockedExchange((volatile long *) o, (long) v);
  }
}
inline unsigned int atomic_compare_exchange_weak_explicit(volatile atomic_uint *o, unsigned int *expected, unsigned int v, memory_order success, memory_order failure)
{
  unsigned int former, e=*expected;
  switch(success)
  {
#ifdef InterlockedExchangeAcquire
  case memory_order_acquire:
    former=(unsigned int) InterlockedCompareExchangeAcquire((volatile long *) o, (long) v, (long) e);
    break;
  case memory_order_release:
    former=(unsigned int) InterlockedCompareExchangeRelease((volatile long *) o, (long) v, (long) e);
    break;
#endif
  default:
    former=(unsigned int) InterlockedCompareExchange((volatile long *) o, (long) v, (long) e);
    break;
  }
  if(former==e) return 1;
  atomic_store_explicit(expected, former, failure);
  return 0;
}
inline unsigned int atomic_compare_exchange_strong_explicit(volatile atomic_uint *o, unsigned int *expected, unsigned int v, memory_order success, memory_order failure)
{
  /* No difference to weak when using Interlocked* functions */
  return atomic_compare_exchange_weak_explicit(o, expected, v, success, failure);
}
inline unsigned int atomic_fetch_add_explicit(volatile atomic_uint *o, unsigned int v, memory_order order)
{
  switch(order)
  {
#ifdef InterlockedExchangeAddAcquire
  case memory_order_acquire:
    return (unsigned int) InterlockedExchangeAddAcquire((volatile long *) o, v);
  case memory_order_release:
    return (unsigned int) InterlockedExchangeAddRelease((volatile long *) o, v);
#endif
  default:
    return (unsigned int) InterlockedExchangeAdd((volatile long *) o, (long) v);
  }
}
#endif
#ifdef __GNUC__
#error Awaiting implementation
#endif




/****************** Declare and define just those bits of threads.h we need ***********************/
enum mtx_types
{
  mtx_plain=0,
  mtx_recursive=1,
  mtx_timed=2
};
enum thrd_results
{
  thrd_success,
  thrd_timeout,
  thrd_busy,
  thrd_error,
  thrd_nomem
};

struct timespec
{
  time_t tv_sec;
  long tv_nsec;
};

#ifdef _MSC_VER
typedef CONDITION_VARIABLE cnd_t;
typedef SRWLOCK mtx_t;

inline int cnd_broadcast(cnd_t *cond) { WakeAllConditionVariable(cond); return thrd_success; }
inline void cnd_destroy(cnd_t *cond) { }
inline int cnd_init(cnd_t *cond) { InitializeConditionVariable(cond); return thrd_success; }
inline int cnd_signal(cnd_t *cond) { WakeConditionVariable(cond); return thrd_success; }
inline int cnd_timedwait(cnd_t *RESTRICT cond, mtx_t *RESTRICT mtx, const struct timespec *RESTRICT ts);
inline int cnd_wait(cnd_t *cond, mtx_t *mtx) { return SleepConditionVariableSRW(cond, mtx, INFINITE, 0) ? thrd_success : thrd_timeout; }

inline void mtx_destroy(mtx_t *mtx) { }
inline int mtx_init(mtx_t *mtx, int type) { InitializeSRWLock(mtx); return thrd_success; }
inline int mtx_lock(mtx_t *mtx) { AcquireSRWLockExclusive(mtx); return thrd_success; }
inline int mtx_timedlock(mtx_t *RESTRICT mtx, const struct timespec *RESTRICT ts);
inline int mtx_trylock(mtx_t *mtx) { return TryAcquireSRWLockExclusive(mtx) ? thrd_success : thrd_busy; }
inline int mtx_unlock(mtx_t *mtx) { ReleaseSRWLockExclusive(mtx); return thrd_success; }

#endif





/****************** Declare and define just those bits of threads.h we need ***********************/
#ifdef _MSC_VER
typedef int (*thrd_start_t)(void *);
typedef uintptr_t thrd_t;

inline int thrd_create(thrd_t *thr, thrd_start_t func, void *arg)
{
  *thr=_beginthread(func, 0, arg);
  return thrd_success;
}
inline int thrd_sleep(const struct timespec *duration, const struct timespec *remaining)
{
  Sleep((DWORD)(duration->tv_sec*1000+duration->tv_nsec/1000000));
  return thrd_success;
}
inline void thrd_yield(void)
{
  Sleep(0);
}
#endif

#endif
#endif
