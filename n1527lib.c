/* n1527lib.c
Implements the N1527 proposal for the C programming language
(C) 2010-2011 Niall Douglas http://www.nedproductions.biz/


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "n1527lib.h"
#include "N1572/c1x_compat.h"
#include <errno.h>

#define MAX_ALLOCATORS 8
#define MAX_POOLS 64

static mtx_t staticdatalock;
static struct mpool_APIset allocators[MAX_ALLOCATORS];
static struct pool_s
{
  struct mpool_APIset *allocator;
  const struct mpool_attribute_data **attributes;
  mpool pool;
  size_t count;
} pools[MAX_POOLS];

extern struct mpool_APIset kernelpage_allocator_APIset(void);
extern struct mpool_APIset dlmalloc_allocator_APIset(void);
mpool mpool_obtain(struct mpool_attribute_data **attributes)
{
  if(!pools[0].allocator)
  { // Bootstrap into existence by firing up the kernel page allocator then dlmalloc
    struct mpool_APIset kernelpageAPIset=allocators[0]=kernelpage_allocator_APIset();
    struct mpool_APIset defaultAPIset=allocators[1]=dlmalloc_allocator_APIset();

    mtx_init(&staticdatalock, mtx_plain);
    mtx_lock(&staticdatalock);
    // We guarantee that their rateattributes function will always get called
    kernelpageAPIset.rateattributes(NULL);
    defaultAPIset.rateattributes(NULL);
    pools[1].allocator=&allocators[0];
    pools[1].pool=kernelpageAPIset.createpool(NULL);
    pools[0].allocator=&allocators[1];
    pools[0].pool=defaultAPIset.createpool(NULL);
    mtx_unlock(&staticdatalock);
  }
  if(!attributes) return pools[0].pool;
  else
  {
    size_t n, maxn, maxidx;
    int maxscore=INT_MIN;
    struct scores_s
    {
      int score;
      struct mpool_APIset *allocator;
    } scores[MAX_ALLOCATORS];
    int comparescore(const void *a, const void *b);
    mtx_lock(&staticdatalock);
    for(maxn=0; maxn<MAX_ALLOCATORS && allocators[maxn].rateattributes; maxn++)
      scores[maxn].score=(scores[maxn].allocator=&allocators[maxn])->rateattributes(attributes);
    //qsort(&scores, n, sizeof(struct scores_s), comparescore); maxidx=0;
    for(maxidx=(size_t)-1, n=0; n<maxn; n++)
    {
      if(scores[n].score>maxscore) maxidx=n;
    }
    if(INT_MIN!=maxscore)
    { // Do we already have a pool matching this allocator and these attributes?
      for(n=0; n<MAX_POOLS && pools[n].pool; n++)
      {
        if(pools[n].allocator==scores[maxidx].allocator)
        {
          int comparison;
          const struct mpool_attribute_data **a=attributes, **b;
          for(; *a; a++)
          {
            for(b=pools[n].attributes; *b && (*b)->id!=(*a)->id; b++);
            if(!*b) break;
            comparison=(*a==*b) ? 0 : memcmp(*a, *b, (*b)->length);
            if(comparison) break;
          }
          if(!*a)
          { // Everything in attributes was found in this pool, so what about the converse?
            for(b=pools[n].attributes; *b; b++)
            {
              for(a=attributes; *a && (*b)->id!=(*a)->id; a++);
              if(!*b) break;
              comparison=(*a==*b) ? 0 : memcmp(*a, *b, (*b)->length);
              if(comparison) break;
            }
            if(!*b)
            { // They're identical, so return existing pool
              mpool ret=pools[n].pool;
              pools[n].count++;
              mtx_unlock(&staticdatalock);
              return ret;
            }
          }
        }
      }
      // No existing pool, so make me a new one
      for(n=0; n<MAX_POOLS && pools[n].pool; n++);
      if(MAX_POOLS==n)
      {
        mtx_unlock(&staticdatalock);
        errno=ENOMEM;
        return NULL;
      }
      if((pools[n].pool=pools[n].allocator->createpool(attributes)))
      {
        pools[n].allocator=scores[maxidx].allocator;
        pools[n].attributes=attributes;
        pools[n].count=1;
        mtx_unlock(&staticdatalock);
        return pools[n].pool;
      }
    }
    mtx_unlock(&staticdatalock);
    return NULL;
  }
}
int comparescore(const void *_a, const void *_b)
{
  struct scores_s
  {
    int score;
    struct mpool_APIset *allocator;
  } *a, *b;
  a=(struct scores_s *) _a;
  b=(struct scores_s *) _b;
  if(a->score>b->score) return -1;
  else if(a->score<b->score) return 1;
  else return 0;
}


void mpool_release(mpool pool)
{
  if(pool==pools[0].pool || pool==pools[1].pool) return;
  // Needs implementing
#ifdef __GNUC__
#warning mpool_release() not yet implemented
#endif
#ifdef _MSC_VER
#pragma message(__FILE__ ": WARNING: mpool_release() not yet implemented")
#endif
}
size_t mpool_knownpools(mpool *poollist, size_t poollistlen)
{
  size_t n=0;
  for(n=0; n<MAX_POOLS && pools[n].pool; n++)
  {
    if(n<poollistlen) poollist[n]=pools[n].pool;
  }
  return n;
}
size_t mpool_usagecount(mpool pool)
{
  size_t n=0;
  if(pool==pools[0].pool || pool==pools[1].pool) return (size_t)-1;
  mtx_lock(&staticdatalock);
  for(n=0; n<MAX_POOLS && pools[n].pool; n++)
  {
    if(pools[n].pool==pool) break;
  }
  n=(MAX_POOLS==n) ? 0 : pools[n].count;
  mtx_unlock(&staticdatalock);
  return n;
}
void mpool_sync(mpool pool)
{
#ifdef __GNUC__
#warning mpool_sync() not yet implemented
#endif
#ifdef _MSC_VER
#pragma message(__FILE__ ": WARNING: mpool_sync() not yet implemented")
#endif
}


