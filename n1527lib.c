/* n1527lib.c
Implements the N1527 proposal for the C programming language
(C) 2010-2011 Niall Douglas http://www.nedproductions.biz/


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#include "n1527lib.h"
#include "N1572/c1x_compat.h"
#include <errno.h>

#define MAX_ALLOCATORS 8
#define MAX_POOLS 64

static mtx_t staticdatalock;
static struct allocator_s
{
  struct mpool_APIset APIset;
  const size_t *RESTRICT alignments, *RESTRICT roundings;
} allocators[MAX_ALLOCATORS];
static struct pool_s
{
  struct allocator_s *allocator;
  const struct mpool_attribute_data **attributes;
  mpool pool;
  size_t count;
} pools[MAX_POOLS];

extern struct mpool_APIset kernelpage_allocator_APIset(void);
extern struct mpool_APIset dlmalloc_allocator_APIset(void);
static struct mpool_attribute_alignment kernelpage_allocator_alignment = { MPOOL_ATTRIBUTE_ALIGNMENT, mpool_attribute_alignment_compare };
static struct mpool_attribute_sizerounding kernelpage_allocator_sizerounding = { MPOOL_ATTRIBUTE_SIZEROUNDING, mpool_attribute_sizerounding_compare };
static struct mpool_attribute_data *kernelpage_allocator_attributes[]= {
  (struct mpool_attribute_data *) &kernelpage_allocator_alignment,
  (struct mpool_attribute_data *) &kernelpage_allocator_sizerounding,
  0
};
static struct mpool_attribute_alignment dlmalloc_allocator_alignment = { MPOOL_ATTRIBUTE_ALIGNMENT, mpool_attribute_alignment_compare };
static struct mpool_attribute_sizerounding dlmalloc_allocator_sizerounding = { MPOOL_ATTRIBUTE_SIZEROUNDING, mpool_attribute_sizerounding_compare };
static struct mpool_attribute_data *dlmalloc_allocator_attributes[]= {
  (struct mpool_attribute_data *) &dlmalloc_allocator_alignment,
  (struct mpool_attribute_data *) &dlmalloc_allocator_sizerounding,
  0
};
static void initialise_static_data(void)
{
  mtx_init(&staticdatalock, mtx_plain);
  // Bootstrap into existence by firing up the kernel page allocator then dlmalloc
  allocators[0].APIset=kernelpage_allocator_APIset();
  allocators[1].APIset=dlmalloc_allocator_APIset();
  // Configure attributes for the kernel page allocator
  allocators[0].APIset.rateattributes(&allocators[0].alignments, &allocators[0].roundings, NULL);
  kernelpage_allocator_alignment.alignment=allocators[0].alignments[0];
  kernelpage_allocator_sizerounding.rounding=allocators[0].roundings[0];
  // Instantiate kernel page allocator
  pools[1].allocator=&allocators[0];
  pools[1].attributes=kernelpage_allocator_attributes;
  if(!(pools[1].pool=pools[1].allocator->APIset.createpool(kernelpage_allocator_attributes, pools[1].pool)))
  {
    abort();
  }
  pools[1].count=-1;
  // Configure attributes for dlmalloc
  allocators[1].APIset.rateattributes(&allocators[1].alignments, &allocators[1].roundings, NULL);
  dlmalloc_allocator_alignment.alignment=allocators[1].alignments[0];
  dlmalloc_allocator_sizerounding.rounding=allocators[1].roundings[0];
  // Instantiate dlmalloc
  pools[0].allocator=&allocators[1];
  pools[0].attributes=dlmalloc_allocator_attributes;
  if(!(pools[0].pool=pools[0].allocator->APIset.createpool(dlmalloc_allocator_attributes, pools[1].pool)))
  {
    abort();
  }
  pools[0].count=-1;
}

size_t mpool_minimum_roundings(size_t roundings[], size_t size)
{
  size_t n, m, idx=0;
  if(!pools[0].allocator) initialise_static_data();
  mtx_lock(&staticdatalock);
  for(n=0; n<MAX_ALLOCATORS && allocators[n].APIset.createpool; n++)
  {
    const size_t *RESTRICT _roundings;
    for(_roundings=allocators[n].roundings; *_roundings; _roundings++)
    {
      for(m=0; m<size && m<idx; m++)
      {
        if(*_roundings<=roundings[m]) break;
      }
      if(m<size)
      {
        if(*_roundings!=roundings[m])
        {
          memmove(roundings+m+1, roundings+m, (idx-m)*sizeof(size_t));
          roundings[m]=*_roundings;
          idx++;
        }
      }
      else idx++;
    }
  }
  mtx_unlock(&staticdatalock);
  return idx;
}


mpool mpool_obtain(struct mpool_attribute_data **attributes)
{
  if(!pools[0].allocator) initialise_static_data();
  if(MPOOL_DEFAULT==attributes) return pools[0].pool;
  else if(MPOOL_KERNEL==attributes) return pools[1].pool;
  else
  {
    size_t n, maxn, maxidx;
    int maxscore=INT_MIN;
    struct scores_s
    {
      int score;
      struct allocator_s *allocator;
    } scores[MAX_ALLOCATORS];
    int comparescore(const void *a, const void *b);
    mtx_lock(&staticdatalock);
    for(maxn=0; maxn<MAX_ALLOCATORS && allocators[maxn].APIset.createpool; maxn++)
      scores[maxn].score=(scores[maxn].allocator=&allocators[maxn])->APIset.rateattributes(NULL, NULL, attributes);
    //qsort(&scores, n, sizeof(struct scores_s), comparescore); maxidx=0;
    for(maxidx=(size_t)-1, n=0; n<maxn; n++)
    {
      if(scores[n].score>maxscore) { maxidx=n; maxscore=scores[n].score; }
    }
    if(INT_MIN!=maxscore)
    { // Do we already have a pool matching this allocator and these attributes?
      for(n=0; n<MAX_POOLS && pools[n].pool; n++)
      {
        if(pools[n].allocator==scores[maxidx].allocator)
        {
          int comparison;
          const struct mpool_attribute_data **a=attributes, **b;
          for(; *a; a++)
          {
            for(b=pools[n].attributes; *b && (*b)->id!=(*a)->id; b++);
            // If there is an attribute in requested that is not in existing, make a new pool
            if(!*b) break;
            comparison=(*a==*b) ? 0 : ((*b)->compare ? (*b)->compare(*b, *a) : memcmp(*a, *b, sizeof(struct mpool_attribute_data)));
            if(comparison) break;
          }
          if(!*a)
          { // Everything in attributes was found in this pool, so what about the converse?
            for(b=pools[n].attributes; *b; b++)
            {
              for(a=attributes; *a && (*b)->id!=(*a)->id; a++);
              // If there is an attribute in existing that is not in requested, ask compare function if the attribute is important
              comparison=(*a==*b) ? 0 : ((*b)->compare ? (*b)->compare(*b, *a) : (*a ? memcmp(*a, *b, sizeof(struct mpool_attribute_data)) : 1));
              if(comparison) break;
            }
            if(!*b)
            { // They're identical, so return existing pool
              mpool ret=pools[n].pool;
              if(n>1) pools[n].count++;
              mtx_unlock(&staticdatalock);
              return ret;
            }
          }
        }
      }
    }
    // No existing pool, so make me a new one
    for(n=0; n<MAX_POOLS && pools[n].pool; n++);
    if(MAX_POOLS==n)
    {
      mtx_unlock(&staticdatalock);
      errno=ENOMEM;
      return NULL;
    }
    if((pools[n].pool=scores[maxidx].allocator->APIset.createpool(attributes, pools[1].pool)))
    {
      pools[n].allocator=scores[maxidx].allocator;
      pools[n].attributes=attributes;
      pools[n].count=1;
      mtx_unlock(&staticdatalock);
      return pools[n].pool;
    }
    mtx_unlock(&staticdatalock);
    errno=ENOMEM;
    return NULL;
  }
}
int comparescore(const void *_a, const void *_b)
{
  struct scores_s
  {
    int score;
    struct mpool_APIset *allocator;
  } *a, *b;
  a=(struct scores_s *) _a;
  b=(struct scores_s *) _b;
  if(a->score>b->score) return -1;
  else if(a->score<b->score) return 1;
  else return 0;
}


void mpool_release(mpool pool)
{
  if(pool==pools[0].pool || pool==pools[1].pool) return;
  // Needs implementing
#ifdef __GNUC__
#warning mpool_release() not yet implemented
#endif
#ifdef _MSC_VER
#pragma message(__FILE__ ": WARNING: mpool_release() not yet implemented")
#endif
}
size_t mpool_knownpools(mpool *poollist, size_t poollistlen)
{
  size_t n=0;
  for(n=0; n<MAX_POOLS && pools[n].pool; n++)
  {
    if(n<poollistlen) poollist[n]=pools[n].pool;
  }
  return n;
}
_Bool mpool_info(mpool pool, size_t *RESTRICT usagecount, const size_t *RESTRICT alignments[], const size_t *RESTRICT roundings[], const struct mpool_attribute_data ***RESTRICT attributes)
{
  size_t n=0;
  if(alignments || roundings) ((struct mpool_s_ *) pool)->APIset->rateattributes(alignments, roundings, NULL);
  if(!usagecount && !attributes) return 1;
  mtx_lock(&staticdatalock);
  for(n=0; n<MAX_POOLS && pools[n].pool; n++)
  {
    if(pools[n].pool==pool) break;
  }
  if(MAX_POOLS==n)
  {
    if(usagecount) *usagecount=-1;
    if(attributes) *attributes=0;
    mtx_unlock(&staticdatalock);
    return 0;
  }
  if(usagecount) *usagecount=pools[n].count;
  if(attributes) *attributes=pools[n].attributes;
  mtx_unlock(&staticdatalock);
  return 1;
}
void mpool_sync(mpool pool)
{
#ifdef __GNUC__
#warning mpool_sync() not yet implemented
#endif
#ifdef _MSC_VER
#pragma message(__FILE__ ": WARNING: mpool_sync() not yet implemented")
#endif
}


